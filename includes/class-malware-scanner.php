<?php

/**
 * SecureAura Advanced Malware Scanner
 *
 * Revolutionary malware detection with multi-layer analysis
 *
 * @package    SecureAura
 * @subpackage SecureAura/modules
 * @since      3.0.0
 */

// Prevent direct access
if (!defined('ABSPATH')) {
    exit('Direct access denied.');
}

/**
 * SecureAura Malware Scanner Class
 *
 * Advanced malware detection system with:
 * - Signature-based detection
 * - Heuristic analysis
 * - Behavioral pattern recognition
 * - Real-time file monitoring
 * - AI-powered threat classification
 *
 * @since      3.0.0
 * @package    SecureAura
 * @subpackage SecureAura/modules
 * @author     Bitekservices
 */
class Secure_Aura_Malware_Scanner
{

    /**
     * Scanner configuration.
     *
     * @since    3.0.0
     * @access   private
     * @var      array    $config    Scanner configuration array.
     */
    private $config;

    /**
     * Database manager instance.
     *
     * @since    3.0.0
     * @access   private
     * @var      object    $db_manager    Database manager instance.
     */
    private $db_manager;

    /**
     * Malware signatures database.
     *
     * @since    3.0.0
     * @access   private
     * @var      array    $signatures    Malware signatures array.
     */
    private $signatures;

    /**
     * Heuristic rules for suspicious pattern detection.
     *
     * @since    3.0.0
     * @access   private
     * @var      array    $heuristic_rules    Heuristic detection rules.
     */
    private $heuristic_rules;

    /**
     * Current scan session data.
     *
     * @since    3.0.0
     * @access   private
     * @var      array    $scan_session    Current scan session information.
     */
    private $scan_session;

    /**
     * Initialize the malware scanner.
     *
     * @since    3.0.0
     * @param    array $config Scanner configuration.
     */
    public function __construct($config = [])
    {
        $this->config = array_merge($this->get_default_config(), $config);
        $this->load_signatures();
        $this->load_heuristic_rules();
        $this->init_scan_session();
    }

    /**
     * Get default scanner configuration.
     *
     * @since    3.0.0
     * @return   array Default configuration.
     */
    private function get_default_config()
    {
        return [
            // Scan settings
            'max_file_size' => 50 * 1024 * 1024, // 50MB
            'max_scan_time' => 300, // 5 minutes
            'max_files_per_batch' => 1000,
            'deep_scan_enabled' => true,
            'heuristic_analysis' => true,
            'signature_detection' => true,
            'real_time_protection' => true,

            // Performance settings
            'memory_limit' => '256M',
            'scan_timeout' => 30,
            'parallel_scanning' => false,
            'background_scanning' => true,

            // Detection thresholds
            'threat_score_threshold' => 0.7,
            'suspicious_score_threshold' => 0.5,
            'false_positive_threshold' => 0.3,

            // File type filters
            'scan_file_types' => [
                'php',
                'js',
                'html',
                'htm',
                'css',
                'sql',
                'py',
                'pl',
                'sh',
                'bat',
                'exe',
                'dll',
                'so',
                'jar',
                'class',
                'asp',
                'aspx',
                'jsp',
                'rb'
            ],

            // Exclusions
            'exclude_dirs' => [
                'wp-content/cache',
                'wp-content/backup',
                'wp-content/updraft',
                'node_modules',
                '.git',
                '.svn'
            ],

            // Actions
            'auto_quarantine' => true,
            'auto_clean' => false,
            'backup_before_clean' => true,
            'email_notifications' => true,
        ];
    }

    /**
     * Initialize the scanner.
     *
     * @since    3.0.0
     */
    public function init_scanner()
    {
        // Set up real-time file monitoring
        if ($this->config['real_time_protection']) {
            $this->init_real_time_protection();
        }

        // Register file upload scanner
        add_filter('wp_handle_upload_prefilter', [$this, 'scan_uploaded_file'], 10, 1);

        // Register theme/plugin file change monitor
        add_action('upgrader_process_complete', [$this, 'scan_after_update'], 10, 2);

        // Schedule background scans
        if (!wp_next_scheduled('secure_aura_background_scan')) {
            wp_schedule_event(time(), 'hourly', 'secure_aura_background_scan');
        }
        add_action('secure_aura_background_scan', [$this, 'run_background_scan']);

        // Initialize database manager
        $this->init_database_manager();
    }

    /**
     * Load malware signatures from database and files.
     *
     * @since    3.0.0
     */
    private function load_signatures()
    {
        // Load cached signatures
        $cached_signatures = get_transient('secure_aura_malware_signatures');
        if ($cached_signatures) {
            $this->signatures = $cached_signatures;
            return;
        }

        // Load signatures from file
        $signatures_file = SECURE_AURA_PLUGIN_DIR . 'config/malware-signatures.php';
        if (file_exists($signatures_file)) {
            $file_signatures = include $signatures_file;
        } else {
            $file_signatures = $this->get_default_signatures();
        }

        // Load signatures from database
        $db_signatures = $this->load_database_signatures();

        // Merge and cache signatures
        $this->signatures = array_merge($file_signatures, $db_signatures);
        set_transient('secure_aura_malware_signatures', $this->signatures, HOUR_IN_SECONDS);
    }

    /**
     * Get default malware signatures.
     *
     * @since    3.0.0
     * @return   array Default signatures.
     */
    private function get_default_signatures()
    {
        return [
            // PHP malware signatures
            'php_malware' => [
                '/eval\s*\(\s*base64_decode/i',
                '/eval\s*\(\s*gzinflate/i',
                '/eval\s*\(\s*str_rot13/i',
                '/eval\s*\(\s*gzuncompress/i',
                '/system\s*\(\s*base64_decode/i',
                '/exec\s*\(\s*base64_decode/i',
                '/shell_exec\s*\(\s*base64_decode/i',
                '/passthru\s*\(\s*base64_decode/i',
                '/\$_(?:GET|POST|REQUEST|COOKIE)\[.{0,15}\]\(\$_(?:GET|POST|REQUEST)/i',
                '/chr\s*\(\s*\d+\s*\)\s*\.\s*chr\s*\(\s*\d+\s*\)/i',
                '/\\x[0-9a-f]{2}\\x[0-9a-f]{2}/i',
                '/preg_replace\s*\(\s*["\'][^"\']*e["\']/',
            ],

            // JavaScript malware signatures
            'js_malware' => [
                '/String\.fromCharCode\s*\(/i',
                '/document\.write\s*\(\s*unescape/i',
                '/eval\s*\(\s*unescape/i',
                '/\.innerHTML\s*=.*fromCharCode/i',
                '/iframe.*src.*javascript:/i',
                '/document\.createElement\s*\(\s*["\']script["\']\s*\)/i',
            ],

            // SQL injection patterns
            'sql_injection' => [
                '/union\s+select/i',
                '/or\s+1\s*=\s*1/i',
                '/drop\s+table/i',
                '/insert\s+into/i',
                '/update\s+.*set/i',
                '/delete\s+from/i',
                '/exec\s*\(/i',
                '/sp_executesql/i',
            ],

            // File inclusion vulnerabilities
            'file_inclusion' => [
                '/include\s*\(\s*\$_(?:GET|POST|REQUEST)/i',
                '/require\s*\(\s*\$_(?:GET|POST|REQUEST)/i',
                '/include_once\s*\(\s*\$_(?:GET|POST|REQUEST)/i',
                '/require_once\s*\(\s*\$_(?:GET|POST|REQUEST)/i',
                '/file_get_contents\s*\(\s*\$_(?:GET|POST|REQUEST)/i',
            ],

            // Backdoor patterns
            'backdoors' => [
                '/FilesMan/i',
                '/c99shell/i',
                '/r57shell/i',
                '/WSO\s*=/i',
                '/IndoXploit/i',
                '/\${"GLOBALS"}\[/i',
                '/\${"\x47\x4c\x4f\x42\x41\x4c\x53"}/i',
                '/base64_decode\s*\(\s*["\'][\w+\/=]{100,}["\']\s*\)/i',
            ],

            // Crypto mining patterns
            'crypto_miners' => [
                '/coinhive/i',
                '/jsecoin/i',
                '/cryptoloot/i',
                '/webminepool/i',
                '/coin-hive/i',
                '/miner\.start/i',
                '/CoinIMP/i',
                '/deepMiner/i',
            ],

            // Phishing patterns
            'phishing' => [
                '/paypal.*login/i',
                '/amazon.*signin/i',
                '/facebook.*login/i',
                '/google.*signin/i',
                '/microsoft.*login/i',
                '/apple.*signin/i',
                '/updateaccount/i',
                '/verifyaccount/i',
            ]
        ];
    }

    /**
     * Load signatures from database.
     *
     * @since    3.0.0
     * @return   array Database signatures.
     */
    private function load_database_signatures()
    {
        global $wpdb;

        $table_name = $wpdb->prefix . SECURE_AURA_TABLE_THREATS;

        $results = $wpdb->get_results("
            SELECT threat_type, indicator_value 
            FROM {$table_name} 
            WHERE indicator_type = 'pattern' 
            AND is_active = 1 
            AND confidence_score > 0.5
        ");

        $signatures = [];
        foreach ($results as $row) {
            if (!isset($signatures[$row->threat_type])) {
                $signatures[$row->threat_type] = [];
            }
            $signatures[$row->threat_type][] = $row->indicator_value;
        }

        return $signatures;
    }

    /**
     * Load heuristic analysis rules.
     *
     * @since    3.0.0
     */
    private function load_heuristic_rules()
    {
        $this->heuristic_rules = [
            // Suspicious PHP patterns
            'suspicious_php' => [
                'rule' => '/(?:eval|exec|system|shell_exec|passthru|file_get_contents|fopen|fwrite|chmod|unlink)/i',
                'weight' => 0.3,
                'description' => 'Contains potentially dangerous PHP functions',
            ],

            // Obfuscated code
            'obfuscation' => [
                'rule' => '/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\xFF]{10,}/',
                'weight' => 0.5,
                'description' => 'Contains binary or obfuscated content',
            ],

            // Base64 encoded content
            'base64_content' => [
                'rule' => '/[A-Za-z0-9+\/]{100,}={0,2}/',
                'weight' => 0.4,
                'description' => 'Contains large base64 encoded strings',
            ],

            // Multiple encoding layers
            'multiple_encoding' => [
                'rule' => '/(?:base64_decode|gzinflate|gzuncompress|str_rot13|rawurldecode|urldecode).*(?:base64_decode|gzinflate|gzuncompress|str_rot13|rawurldecode|urldecode)/i',
                'weight' => 0.7,
                'description' => 'Uses multiple encoding/decoding functions',
            ],

            // Suspicious file operations
            'file_operations' => [
                'rule' => '/(?:file_put_contents|fwrite|fputs).*(?:\$_GET|\$_POST|\$_REQUEST|\$_COOKIE)/i',
                'weight' => 0.6,
                'description' => 'Writes user input to files',
            ],

            // Network operations
            'network_operations' => [
                'rule' => '/(?:curl_exec|file_get_contents|fsockopen|socket_create).*(?:http|ftp):\/\//i',
                'weight' => 0.4,
                'description' => 'Makes external network connections',
            ],

            // Dynamic function calls
            'dynamic_calls' => [
                'rule' => '/\$[a-zA-Z_][a-zA-Z0-9_]*\s*\(/i',
                'weight' => 0.3,
                'description' => 'Uses variable function calls',
            ],

            // Suspicious file extensions in strings
            'suspicious_extensions' => [
                'rule' => '/\.(?:exe|bat|cmd|scr|pif|com|dll|vbs|js|jar|zip|rar)["\']/i',
                'weight' => 0.4,
                'description' => 'References suspicious file extensions',
            ]
        ];
    }

    /**
     * Initialize scan session.
     *
     * @since    3.0.0
     */
    private function init_scan_session()
    {
        $this->scan_session = [
            'scan_id' => wp_generate_uuid4(),
            'start_time' => microtime(true),
            'files_scanned' => 0,
            'threats_found' => 0,
            'files_quarantined' => 0,
            'files_cleaned' => 0,
            'scan_type' => 'manual',
            'status' => 'initialized',
            'current_file' => '',
            'progress' => 0,
        ];
    }

    /**
     * Initialize database manager.
     *
     * @since    3.0.0
     */
    private function init_database_manager()
    {
        if (class_exists('Secure_Aura_Database_Manager')) {
            $this->db_manager = new Secure_Aura_Database_Manager();
        }
    }

    /**
     * Run full system scan.
     *
     * @since    3.0.0
     * @param    array $options Scan options.
     * @return   array Scan results.
     */
    public function run_full_scan($options = [])
    {
        // Set time and memory limits
        $this->set_scan_limits();

        // Initialize scan session
        $this->scan_session['scan_type'] = 'full';
        $this->scan_session['status'] = 'running';
        $this->scan_session['options'] = $options;

        // Set scan in progress
        set_transient('secure_aura_scan_in_progress', $this->scan_session, $this->config['max_scan_time']);

        try {
            // Get scan directories
            $scan_dirs = $this->get_scan_directories($options);

            $results = [
                'scan_id' => $this->scan_session['scan_id'],
                'scan_type' => 'full',
                'start_time' => current_time('mysql'),
                'status' => 'completed',
                'files_scanned' => 0,
                'threats_found' => [],
                'suspicious_files' => [],
                'clean_files' => 0,
                'skipped_files' => 0,
                'errors' => [],
                'performance' => [],
            ];

            foreach ($scan_dirs as $dir) {
                $dir_results = $this->scan_directory($dir, $options);
                $results = $this->merge_scan_results($results, $dir_results);

                // Check for timeout
                if ($this->is_scan_timeout()) {
                    $results['status'] = 'timeout';
                    break;
                }
            }

            // Finalize scan
            $results['end_time'] = current_time('mysql');
            $results['scan_duration'] = microtime(true) - $this->scan_session['start_time'];
            $results['memory_usage'] = memory_get_peak_usage(true);

            // Save scan results
            $this->save_scan_results($results);

            // Send notifications
            if (!empty($results['threats_found'])) {
                $this->send_threat_notification($results);
            }

            if (!empty($results['threats_found'])) {
                $email = new Secure_Aura_Email_Notifications();
                $email->send_threat_alert($results['threats_found'][0], count($results['threats_found']));
            }

            // Send scan report
            $email = new Secure_Aura_Email_Notifications();
            $email->send_scan_report($results);

            return $results;
        } catch (Exception $e) {
            $this->log_scan_error($e->getMessage());
            return [
                'status' => 'error',
                'error' => $e->getMessage(),
                'scan_id' => $this->scan_session['scan_id'],
            ];
        } finally {
            // Clean up
            delete_transient('secure_aura_scan_in_progress');
            $this->cleanup_scan_session();
        }
    }

    /**
     * Scan a specific directory.
     *
     * @since    3.0.0
     * @param    string $directory Directory path to scan.
     * @param    array  $options   Scan options.
     * @return   array  Scan results for the directory.
     */
    private function scan_directory($directory, $options = [])
    {
        if (!is_dir($directory) || !is_readable($directory)) {
            return ['errors' => ["Directory not accessible: {$directory}"]];
        }

        $results = [
            'directory' => $directory,
            'files_scanned' => 0,
            'threats_found' => [],
            'suspicious_files' => [],
            'clean_files' => 0,
            'skipped_files' => 0,
            'errors' => [],
        ];

        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($directory, RecursiveDirectoryIterator::SKIP_DOTS),
            RecursiveIteratorIterator::LEAVES_ONLY
        );

        $file_count = 0;
        foreach ($iterator as $file) {
            // Check scan limits
            if ($this->is_scan_timeout() || $file_count >= $this->config['max_files_per_batch']) {
                break;
            }

            if ($file->isFile()) {
                $file_path = $file->getRealPath();

                // Skip excluded files and directories
                if ($this->should_skip_file($file_path)) {
                    $results['skipped_files']++;
                    continue;
                }

                // Update progress
                $this->update_scan_progress($file_path);

                // Scan the file
                $scan_result = $this->scan_file($file_path, $options);

                if ($scan_result['status'] === 'threat') {
                    $results['threats_found'][] = $scan_result;
                } elseif ($scan_result['status'] === 'suspicious') {
                    $results['suspicious_files'][] = $scan_result;
                } elseif ($scan_result['status'] === 'clean') {
                    $results['clean_files']++;
                } elseif ($scan_result['status'] === 'error') {
                    $results['errors'][] = $scan_result['error'];
                }

                $results['files_scanned']++;
                $file_count++;

                // Memory management
                if ($file_count % 100 === 0) {
                    $this->manage_memory();
                }
            }
        }

        return $results;
    }

    /**
     * Scan a single file for threats.
     *
     * @since    3.0.0
     * @param    string $file_path Path to file to scan.
     * @param    array  $options   Scan options.
     * @return   array  Scan result for the file.
     */
    public function scan_file($file_path, $options = [])
    {
        if (!file_exists($file_path) || !is_readable($file_path)) {
            return [
                'status' => 'error',
                'error' => 'File not accessible',
                'file_path' => $file_path,
            ];
        }

        $file_size = filesize($file_path);
        if ($file_size > $this->config['max_file_size']) {
            return [
                'status' => 'skipped',
                'reason' => 'File too large',
                'file_path' => $file_path,
                'file_size' => $file_size,
            ];
        }

        $file_content = file_get_contents($file_path);
        if ($file_content === false) {
            return [
                'status' => 'error',
                'error' => 'Cannot read file content',
                'file_path' => $file_path,
            ];
        }

        $result = [
            'file_path' => $file_path,
            'file_size' => $file_size,
            'file_hash' => hash('sha256', $file_content),
            'scan_time' => microtime(true),
            'threats' => [],
            'suspicious_patterns' => [],
            'threat_score' => 0.0,
            'status' => 'clean',
        ];

        // Signature-based detection
        if ($this->config['signature_detection']) {
            $signature_results = $this->check_signatures($file_content, $file_path);
            $result['threats'] = array_merge($result['threats'], $signature_results);
        }

        // Heuristic analysis
        if ($this->config['heuristic_analysis']) {
            $heuristic_results = $this->analyze_heuristics($file_content, $file_path);
            $result['suspicious_patterns'] = $heuristic_results['patterns'];
            $result['threat_score'] += $heuristic_results['score'];
        }

        // File metadata analysis
        $metadata_results = $this->analyze_file_metadata($file_path);
        $result['threat_score'] += $metadata_results['score'];

        // Determine final status
        if (!empty($result['threats']) || $result['threat_score'] >= $this->config['threat_score_threshold']) {
            $result['status'] = 'threat';

            // Auto-quarantine if enabled
            if ($this->config['auto_quarantine']) {
                $quarantine_result = $this->quarantine_file($file_path, $result);
                $result['quarantined'] = $quarantine_result['success'];
                $result['quarantine_path'] = $quarantine_result['quarantine_path'] ?? '';
            }
        } elseif ($result['threat_score'] >= $this->config['suspicious_score_threshold']) {
            $result['status'] = 'suspicious';
        }

        $result['scan_time'] = microtime(true) - $result['scan_time'];

        // Log the scan result
        $this->log_file_scan_result($result);

        return $result;
    }

    /**
     * Check file content against malware signatures.
     *
     * @since    3.0.0
     * @param    string $content   File content to check.
     * @param    string $file_path File path for context.
     * @return   array  Detected threats.
     */
    private function check_signatures($content, $file_path)
    {
        $threats = [];

        foreach ($this->signatures as $category => $patterns) {
            foreach ($patterns as $pattern) {
                if (preg_match($pattern, $content, $matches)) {
                    $threats[] = [
                        'type' => 'signature_match',
                        'category' => $category,
                        'pattern' => $pattern,
                        'match' => $matches[0] ?? '',
                        'severity' => $this->get_threat_severity($category),
                        'confidence' => 0.9,
                    ];
                }
            }
        }

        return $threats;
    }

    /**
     * Perform heuristic analysis on file content.
     *
     * @since    3.0.0
     * @param    string $content   File content to analyze.
     * @param    string $file_path File path for context.
     * @return   array  Analysis results.
     */
    private function analyze_heuristics($content, $file_path)
    {
        $patterns = [];
        $total_score = 0.0;

        foreach ($this->heuristic_rules as $rule_name => $rule) {
            if (preg_match($rule['rule'], $content, $matches)) {
                $patterns[] = [
                    'rule' => $rule_name,
                    'description' => $rule['description'],
                    'match' => $matches[0] ?? '',
                    'weight' => $rule['weight'],
                ];

                $total_score += $rule['weight'];
            }
        }

        // Additional heuristics
        $additional_score = $this->calculate_additional_heuristics($content, $file_path);
        $total_score += $additional_score;

        return [
            'patterns' => $patterns,
            'score' => min($total_score, 1.0), // Cap at 1.0
        ];
    }

    /**
     * Calculate additional heuristic scores.
     *
     * @since    3.0.0
     * @param    string $content   File content.
     * @param    string $file_path File path.
     * @return   float  Additional heuristic score.
     */
    private function calculate_additional_heuristics($content, $file_path)
    {
        $score = 0.0;

        // Check entropy (randomness) - high entropy might indicate encryption/obfuscation
        $entropy = $this->calculate_entropy($content);
        if ($entropy > 7.5) {
            $score += 0.3;
        }

        // Check for suspicious file locations
        $suspicious_locations = [
            '/wp-content/uploads/',
            '/wp-includes/',
            '/wp-admin/',
        ];

        foreach ($suspicious_locations as $location) {
            if (strpos($file_path, $location) !== false && pathinfo($file_path, PATHINFO_EXTENSION) === 'php') {
                $score += 0.4;
                break;
            }
        }

        // Check file size vs content ratio
        $readable_chars = strlen(preg_replace('/[^\w\s]/', '', $content));
        $total_chars = strlen($content);

        if ($total_chars > 0) {
            $readable_ratio = $readable_chars / $total_chars;
            if ($readable_ratio < 0.3) {
                $score += 0.2;
            }
        }

        // Check for multiple PHP opening tags
        $php_tags = preg_match_all('/<\?php/', $content);
        if ($php_tags > 5) {
            $score += 0.2;
        }

        return $score;
    }

    /**
     * Calculate entropy of string (measure of randomness).
     *
     * @since    3.0.0
     * @param    string $string Input string.
     * @return   float  Entropy value.
     */
    private function calculate_entropy($string)
    {
        $length = strlen($string);
        if ($length === 0) {
            return 0;
        }

        $frequencies = array_count_values(str_split($string));
        $entropy = 0;

        foreach ($frequencies as $frequency) {
            $probability = $frequency / $length;
            $entropy -= $probability * log($probability, 2);
        }

        return $entropy;
    }

    /**
     * Analyze file metadata for suspicious characteristics.
     *
     * @since    3.0.0
     * @param    string $file_path File path to analyze.
     * @return   array  Metadata analysis results.
     */
    private function analyze_file_metadata($file_path)
    {
        $score = 0.0;
        $metadata = [];

        $stat = stat($file_path);
        if ($stat) {
            $metadata['size'] = $stat['size'];
            $metadata['modified'] = $stat['mtime'];
            $metadata['accessed'] = $stat['atime'];
            $metadata['permissions'] = substr(sprintf('%o', $stat['mode']), -4);

            // Check for suspicious permissions
            if (($stat['mode'] & 0777) === 0777) {
                $score += 0.3; // World writable
            }

            // Check for recently modified files
            if ($stat['mtime'] > (time() - 86400)) {
                $score += 0.1; // Modified in last 24 hours
            }
        }

        // Check file extension vs content type
        $extension = pathinfo($file_path, PATHINFO_EXTENSION);
        $mime_type = mime_content_type($file_path);

        if ($this->is_extension_mime_mismatch($extension, $mime_type)) {
            $score += 0.4;
        }

        return [
            'score' => $score,
            'metadata' => $metadata,
        ];
    }

    /**
     * Check if file extension matches MIME type.
     *
     * @since    3.0.0
     * @param    string $extension File extension.
     * @param    string $mime_type MIME type.
     * @return   bool   True if mismatch detected.
     */
    private function is_extension_mime_mismatch($extension, $mime_type)
    {
        $expected_mimes = [
            'php' => ['text/plain', 'text/x-php', 'application/x-httpd-php'],
            'js' => ['application/javascript', 'text/javascript'],
            'css' => ['text/css'],
            'html' => ['text/html'],
            'htm' => ['text/html'],
        ];

        if (!isset($expected_mimes[$extension])) {
            return false;
        }

        return !in_array($mime_type, $expected_mimes[$extension]);
    }

    /**
     * Get threat severity based on category.
     *
     * @since    3.0.0
     * @param    string $category Threat category.
     * @return   string Severity level.
     */
    private function get_threat_severity($category)
    {
        $severities = [
            'backdoors' => SECURE_AURA_SEVERITY_CRITICAL,
            'php_malware' => SECURE_AURA_SEVERITY_HIGH,
            'js_malware' => SECURE_AURA_SEVERITY_HIGH,
            'sql_injection' => SECURE_AURA_SEVERITY_HIGH,
            'file_inclusion' => SECURE_AURA_SEVERITY_HIGH,
            'crypto_miners' => SECURE_AURA_SEVERITY_MEDIUM,
            'phishing' => SECURE_AURA_SEVERITY_MEDIUM,
        ];

        return $severities[$category] ?? SECURE_AURA_SEVERITY_MEDIUM;
    }

    /**
     * Quarantine a malicious file.
     *
     * @since    3.0.0
     * @param    string $file_path File to quarantine.
     * @param    array  $scan_result Scan result data.
     * @return   array  Quarantine operation result.
     */
    private function quarantine_file($file_path, $scan_result)
    {
        try {
            // Create quarantine directory if it doesn't exist
            if (!file_exists(SECURE_AURA_QUARANTINE_DIR)) {
                wp_mkdir_p(SECURE_AURA_QUARANTINE_DIR);
            }

            // Generate unique quarantine filename
            $quarantine_filename = hash('sha256', $file_path . time()) . '.quarantine';
            $quarantine_path = SECURE_AURA_QUARANTINE_DIR . $quarantine_filename;

            // Create backup if enabled
            if ($this->config['backup_before_clean']) {
                $backup_path = SECURE_AURA_BACKUPS_DIR . $quarantine_filename . '.backup';
                if (!copy($file_path, $backup_path)) {
                    return ['success' => false, 'error' => 'Failed to create backup'];
                }
            }

            // Move file to quarantine
            if (!rename($file_path, $quarantine_path)) {
                return ['success' => false, 'error' => 'Failed to move file to quarantine'];
            }

            // Log quarantine action
            $this->log_quarantine_action($file_path, $quarantine_path, $scan_result);

            // Update database
            global $wpdb;
            $table_name = $wpdb->prefix . SECURE_AURA_TABLE_QUARANTINE;

            $wpdb->insert($table_name, [
                'original_path' => $file_path,
                'quarantine_path' => $quarantine_path,
                'file_hash' => $scan_result['file_hash'],
                'file_size' => $scan_result['file_size'],
                'threat_type' => implode(', ', array_column($scan_result['threats'], 'category')),
                'detection_method' => 'malware_scanner',
                'confidence_score' => min($scan_result['threat_score'], 1.0),
                'quarantined_at' => current_time('mysql'),
                'detected_by' => 'SecureAura Scanner v' . SECURE_AURA_VERSION,
                'scan_details' => json_encode($scan_result),
                'restoration_possible' => 1,
                'action_taken' => 'quarantined',
                'auto_delete_at' => date('Y-m-d H:i:s', time() + (30 * 24 * 60 * 60)), // 30 days
            ]);

            return [
                'success' => true,
                'quarantine_path' => $quarantine_path,
                'backup_created' => $this->config['backup_before_clean'],
            ];
        } catch (Exception $e) {
            return [
                'success' => false,
                'error' => $e->getMessage(),
            ];
        }
    }

    // ... (Additional methods would continue here)

    /**
     * Check if scan should timeout.
     *
     * @since    3.0.0
     * @return   bool True if scan should timeout.
     */
    private function is_scan_timeout()
    {
        return (microtime(true) - $this->scan_session['start_time']) > $this->config['max_scan_time'];
    }

    /**
     * Update scan progress.
     *
     * @since    3.0.0
     * @param    string $current_file Currently scanning file.
     */
    private function update_scan_progress($current_file)
    {
        $this->scan_session['current_file'] = $current_file;
        $this->scan_session['files_scanned']++;

        // Update transient with current progress
        set_transient('secure_aura_scan_progress', [
            'scan_id' => $this->scan_session['scan_id'],
            'files_scanned' => $this->scan_session['files_scanned'],
            'current_file' => basename($current_file),
            'status' => $this->scan_session['status'],
            'progress' => $this->calculate_progress_percentage(),
        ], 300);
    }

    /**
     * Calculate scan progress percentage.
     *
     * @since    3.0.0
     * @return   int Progress percentage.
     */
    private function calculate_progress_percentage()
    {
        if (!isset($this->scan_session['total_files'])) {
            return 0;
        }

        return min(100, round(($this->scan_session['files_scanned'] / $this->scan_session['total_files']) * 100));
    }

    /**
     * Set scan limits for performance.
     *
     * @since    3.0.0
     */
    private function set_scan_limits()
    {
        // Increase memory limit if possible
        if (ini_get('memory_limit') !== -1) {
            ini_set('memory_limit', $this->config['memory_limit']);
        }

        // Increase execution time
        if (!ini_get('safe_mode')) {
            set_time_limit($this->config['max_scan_time']);
        }

        // Disable WordPress maintenance mode during scan
        if (function_exists('wp_maintenance')) {
            remove_action('init', 'wp_maintenance');
        }
    }

    /**
     * Get directories to scan.
     *
     * @since    3.0.0
     * @param    array $options Scan options.
     * @return   array Directories to scan.
     */
    private function get_scan_directories($options = [])
    {
        $default_dirs = [
            ABSPATH,
            WP_CONTENT_DIR,
        ];

        if (isset($options['include_dirs'])) {
            $default_dirs = array_merge($default_dirs, $options['include_dirs']);
        }

        if (isset($options['exclude_dirs'])) {
            $default_dirs = array_diff($default_dirs, $options['exclude_dirs']);
        }

        return array_filter($default_dirs, 'is_dir');
    }

    /**
     * Check if file should be skipped during scan.
     *
     * @since    3.0.0
     * @param    string $file_path File path to check.
     * @return   bool True if file should be skipped.
     */
    private function should_skip_file($file_path)
    {
        // Skip if file is too large
        if (filesize($file_path) > $this->config['max_file_size']) {
            return true;
        }

        // Skip excluded directories
        foreach ($this->config['exclude_dirs'] as $exclude_dir) {
            if (strpos($file_path, $exclude_dir) !== false) {
                return true;
            }
        }

        // Skip non-scannable file types
        $extension = strtolower(pathinfo($file_path, PATHINFO_EXTENSION));
        if (!empty($this->config['scan_file_types']) && !in_array($extension, $this->config['scan_file_types'])) {
            return true;
        }

        // Skip binary files (basic check)
        if ($this->is_likely_binary_file($file_path)) {
            return true;
        }

        // Skip cache and temporary files
        if (preg_match('/\.(cache|tmp|temp|log)$/i', $file_path)) {
            return true;
        }

        return false;
    }

    /**
     * Check if file is likely a binary file.
     *
     * @since    3.0.0
     * @param    string $file_path File path to check.
     * @return   bool True if likely binary.
     */
    private function is_likely_binary_file($file_path)
    {
        $binary_extensions = [
            'jpg',
            'jpeg',
            'png',
            'gif',
            'pdf',
            'zip',
            'rar',
            '7z',
            'tar',
            'gz',
            'mp3',
            'mp4',
            'avi',
            'mov',
            'exe',
            'dll',
            'so',
            'dylib',
            'bin'
        ];

        $extension = strtolower(pathinfo($file_path, PATHINFO_EXTENSION));
        return in_array($extension, $binary_extensions);
    }

    /**
     * Merge scan results from multiple directories.
     *
     * @since    3.0.0
     * @param    array $main_results Main results array.
     * @param    array $dir_results  Directory-specific results.
     * @return   array Merged results.
     */
    private function merge_scan_results($main_results, $dir_results)
    {
        $main_results['files_scanned'] += $dir_results['files_scanned'];
        $main_results['clean_files'] += $dir_results['clean_files'];
        $main_results['skipped_files'] += $dir_results['skipped_files'];

        $main_results['threats_found'] = array_merge(
            $main_results['threats_found'],
            $dir_results['threats_found']
        );

        $main_results['suspicious_files'] = array_merge(
            $main_results['suspicious_files'],
            $dir_results['suspicious_files']
        );

        $main_results['errors'] = array_merge(
            $main_results['errors'],
            $dir_results['errors']
        );

        return $main_results;
    }

    /**
     * Manage memory usage during scan.
     *
     * @since    3.0.0
     */
    private function manage_memory()
    {
        // Force garbage collection
        if (function_exists('gc_collect_cycles')) {
            gc_collect_cycles();
        }

        // Check memory usage
        $memory_usage = memory_get_usage(true);
        $memory_limit = wp_convert_hr_to_bytes(ini_get('memory_limit'));

        if ($memory_usage > ($memory_limit * 0.9)) {
            // Close to memory limit, take action
            $this->log_scan_warning('Approaching memory limit during scan');

            // Clear some caches
            wp_cache_flush();

            // Reduce batch size for remaining files
            $this->config['max_files_per_batch'] = max(50, $this->config['max_files_per_batch'] / 2);
        }
    }

    /**
     * Save scan results to database.
     *
     * @since    3.0.0
     * @param    array $results Scan results to save.
     */
    private function save_scan_results($results)
    {
        // Save to options for quick access
        update_option('secure_aura_last_scan_results', $results);
        update_option('secure_aura_last_scan_time', current_time('mysql'));

        // Log scan completion
        if ($this->db_manager) {
            $this->db_manager->log_event(
                'scan_completed',
                [
                    'scan_id' => $results['scan_id'],
                    'files_scanned' => $results['files_scanned'],
                    'threats_found' => count($results['threats_found']),
                    'suspicious_files' => count($results['suspicious_files']),
                    'scan_duration' => $results['scan_duration'],
                    'memory_usage' => $results['memory_usage'],
                ],
                count($results['threats_found']) > 0 ? SECURE_AURA_SEVERITY_HIGH : SECURE_AURA_SEVERITY_INFO
            );
        }

        // Update statistics
        $this->update_scan_statistics($results);
    }

    /**
     * Update scan statistics.
     *
     * @since    3.0.0
     * @param    array $results Scan results.
     */
    private function update_scan_statistics($results)
    {
        $stats = get_option('secure_aura_scan_statistics', [
            'total_scans' => 0,
            'total_files_scanned' => 0,
            'total_threats_found' => 0,
            'last_scan_date' => null,
        ]);

        $stats['total_scans']++;
        $stats['total_files_scanned'] += $results['files_scanned'];
        $stats['total_threats_found'] += count($results['threats_found']);
        $stats['last_scan_date'] = current_time('mysql');

        update_option('secure_aura_scan_statistics', $stats);
    }

    /**
     * Send threat notification email.
     *
     * @since    3.0.0
     * @param    array $results Scan results.
     */
    private function send_threat_notification($results)
    {
        if (!$this->config['email_notifications']) {
            return;
        }

        $admin_email = get_option('secure_aura_notification_email', get_option('admin_email'));
        $site_name = get_bloginfo('name');
        $threats_count = count($results['threats_found']);

        $subject = sprintf(
            __('[%s] SECURITY ALERT: %d threats detected by SecureAura', 'secure-aura'),
            $site_name,
            $threats_count
        );

        $threat_list = '';
        foreach (array_slice($results['threats_found'], 0, 10) as $threat) {
            $threat_list .= sprintf(
                "• %s (%s)\n",
                $threat['file_path'],
                $threat['status']
            );
        }

        if ($threats_count > 10) {
            $threat_list .= sprintf("... and %d more threats\n", $threats_count - 10);
        }

        $message = sprintf(
            __('SecureAura has detected %d security threats on your website %s.

            THREATS DETECTED:
            %s

            SCAN SUMMARY:
            • Files Scanned: %d
            • Threats Found: %d
            • Suspicious Files: %d
            • Scan Duration: %.2f seconds

            IMMEDIATE ACTIONS TAKEN:
            • Malicious files have been quarantined
            • Site administrators have been notified
            • Incident has been logged for investigation

            RECOMMENDED ACTIONS:
            1. Review the full scan report in your SecureAura dashboard
            2. Verify that quarantined files are indeed malicious
            3. Check for any unauthorized access to your site
            4. Update all plugins and themes to latest versions
            5. Consider changing admin passwords

            View full report: %s

            Stay secure!
            SecureAura Security Team', 'secure-aura'),
            $threats_count,
            home_url(),
            $threat_list,
            $results['files_scanned'],
            $threats_count,
            count($results['suspicious_files']),
            $results['scan_duration'],
            admin_url('admin.php?page=secure-aura&tab=scanner')
        );

        $headers = [
            'Content-Type: text/plain; charset=UTF-8',
            'From: SecureAura Security <security@secureaura.pro>',
            'X-Priority: 1',
            'X-MSMail-Priority: High',
        ];

        wp_mail($admin_email, $subject, $message, $headers);
    }

    /**
     * Log file scan result.
     *
     * @since    3.0.0
     * @param    array $result File scan result.
     */
    private function log_file_scan_result($result)
    {
        if ($result['status'] === 'threat' || $result['status'] === 'suspicious') {
            if ($this->db_manager) {
                $this->db_manager->log_event(
                    $result['status'] === 'threat' ? 'malware_detected' : 'suspicious_file_detected',
                    [
                        'file_path' => $result['file_path'],
                        'file_hash' => $result['file_hash'],
                        'threat_score' => $result['threat_score'],
                        'threats' => $result['threats'],
                        'suspicious_patterns' => $result['suspicious_patterns'],
                        'quarantined' => $result['quarantined'] ?? false,
                    ],
                    $result['status'] === 'threat' ? SECURE_AURA_SEVERITY_HIGH : SECURE_AURA_SEVERITY_MEDIUM
                );
            }
        }
    }

    /**
     * Log quarantine action.
     *
     * @since    3.0.0
     * @param    string $original_path   Original file path.
     * @param    string $quarantine_path Quarantine file path.
     * @param    array  $scan_result     Scan result data.
     */
    private function log_quarantine_action($original_path, $quarantine_path, $scan_result)
    {
        if ($this->db_manager) {
            $this->db_manager->log_event(
                'file_quarantined',
                [
                    'original_path' => $original_path,
                    'quarantine_path' => $quarantine_path,
                    'file_hash' => $scan_result['file_hash'],
                    'threat_score' => $scan_result['threat_score'],
                    'threats_detected' => count($scan_result['threats']),
                ],
                SECURE_AURA_SEVERITY_HIGH
            );
        }
    }

    /**
     * Log scan error.
     *
     * @since    3.0.0
     * @param    string $error_message Error message.
     */
    private function log_scan_error($error_message)
    {
        if ($this->db_manager) {
            $this->db_manager->log_event(
                'scan_error',
                [
                    'error' => $error_message,
                    'scan_id' => $this->scan_session['scan_id'],
                ],
                SECURE_AURA_SEVERITY_MEDIUM
            );
        }

        error_log('SecureAura Scan Error: ' . $error_message);
    }

    /**
     * Log scan warning.
     *
     * @since    3.0.0
     * @param    string $warning_message Warning message.
     */
    private function log_scan_warning($warning_message)
    {
        if ($this->db_manager) {
            $this->db_manager->log_event(
                'scan_warning',
                [
                    'warning' => $warning_message,
                    'scan_id' => $this->scan_session['scan_id'],
                ],
                SECURE_AURA_SEVERITY_LOW
            );
        }
    }

    /**
     * Clean up scan session.
     *
     * @since    3.0.0
     */
    private function cleanup_scan_session()
    {
        // Clean up temporary files
        delete_transient('secure_aura_scan_progress');
        delete_transient('secure_aura_scan_in_progress');

        // Reset scan session
        $this->scan_session = [];
    }

    /**
     * Initialize real-time file protection.
     *
     * @since    3.0.0
     */
    private function init_real_time_protection()
    {
        // Monitor file changes
        // add_action('wp_loaded', [$this, 'check_file_changes']);

        // Monitor new file uploads
        add_filter('wp_handle_upload_prefilter', [$this, 'scan_uploaded_file']);

        // Monitor plugin/theme installations
        add_action('upgrader_process_complete', [$this, 'scan_after_update'], 10, 2);
    }

    /**
     * Scan uploaded file for threats.
     *
     * @since    3.0.0
     * @param    array $file Upload file data.
     * @return   array Modified file data or error.
     */
    public function scan_uploaded_file($file)
    {
        if (!isset($file['tmp_name']) || !file_exists($file['tmp_name'])) {
            return $file;
        }

        // Quick scan of uploaded file
        $scan_result = $this->scan_file($file['tmp_name'], ['quick_scan' => true]);

        if ($scan_result['status'] === 'threat') {
            // Block the upload
            $file['error'] = sprintf(
                __('File upload blocked: Security threat detected. File contains %s', 'secure-aura'),
                implode(', ', array_column($scan_result['threats'], 'category'))
            );

            // Log blocked upload
            if ($this->db_manager) {
                $this->db_manager->log_event(
                    'malicious_upload_blocked',
                    [
                        'filename' => $file['name'],
                        'file_hash' => $scan_result['file_hash'],
                        'threats' => $scan_result['threats'],
                        'threat_score' => $scan_result['threat_score'],
                    ],
                    SECURE_AURA_SEVERITY_HIGH
                );
            }
        }

        return $file;
    }

    /**
     * Scan files after plugin/theme update.
     *
     * @since    3.0.0
     * @param    object $upgrader   Upgrader instance.
     * @param    array  $hook_extra Hook extra data.
     */
    public function scan_after_update($upgrader, $hook_extra)
    {
        if (!isset($hook_extra['type']) || !in_array($hook_extra['type'], ['plugin', 'theme'])) {
            return;
        }

        // Schedule a background scan of updated files
        wp_schedule_single_event(time() + 60, 'secure_aura_scan_updated_files', [
            'type' => $hook_extra['type'],
            'updated_items' => $hook_extra
        ]);
    }

    /**
     * Run background scan (called by cron).
     *
     * @since    3.0.0
     */
    public function run_background_scan()
    {
        if (!$this->config['background_scanning']) {
            return;
        }

        // Check if a scan is already running
        if (get_transient('secure_aura_scan_in_progress')) {
            return;
        }

        // Run a limited background scan
        $this->run_full_scan([
            'background' => true,
            'max_files' => 500,
            'max_time' => 120, // 2 minutes
        ]);
    }

    /**
     * Get current scan status.
     *
     * @since    3.0.0
     * @return   array Current scan status.
     */
    public function get_scan_status()
    {
        $progress = get_transient('secure_aura_scan_progress');
        $in_progress = get_transient('secure_aura_scan_in_progress');

        if ($progress && $in_progress) {
            return [
                'status' => 'running',
                'progress' => $progress,
            ];
        }

        $last_scan = get_option('secure_aura_last_scan_results');
        if ($last_scan) {
            return [
                'status' => 'completed',
                'last_scan' => $last_scan,
            ];
        }

        return [
            'status' => 'idle',
            'last_scan' => null,
        ];
    }

    /**
     * Get scanner statistics.
     *
     * @since    3.0.0
     * @return   array Scanner statistics.
     */
    public function get_scanner_statistics()
    {
        return get_option('secure_aura_scan_statistics', [
            'total_scans' => 0,
            'total_files_scanned' => 0,
            'total_threats_found' => 0,
            'last_scan_date' => null,
        ]);
    }

    /**
     * Update scanner configuration.
     *
     * @since    3.0.0
     * @param    array $new_config New configuration.
     */
    public function update_config($new_config)
    {
        $this->config = array_merge($this->config, $new_config);

        // Reload signatures and rules if needed
        if (isset($new_config['signature_detection']) || isset($new_config['heuristic_analysis'])) {
            $this->load_signatures();
            $this->load_heuristic_rules();
        }
    }

    /**
     * Clean up scanner resources.
     *
     * @since    3.0.0
     */
    public function cleanup()
    {
        // Clear any running scans
        delete_transient('secure_aura_scan_in_progress');
        delete_transient('secure_aura_scan_progress');

        // Clear scheduled background scans
        wp_clear_scheduled_hook('secure_aura_background_scan');
        wp_clear_scheduled_hook('secure_aura_scan_updated_files');

        // Clean up temporary scan data
        delete_option('secure_aura_scan_temp_data');
    }
}
